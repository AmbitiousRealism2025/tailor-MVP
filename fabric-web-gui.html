<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabric AI - Web Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        select, textarea, input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        select:focus, textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 150px;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .output-section {
            margin-top: 30px;
        }

        .output {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 600px;
            overflow-y: auto;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 30px;
            color: #667eea;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            border-radius: 12px;
            border: 2px solid #e0e6ff;
            margin: 20px 0;
        }

        .loading.active {
            display: block;
        }

        .loading-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .spinner {
            border: 4px solid #f0f2ff;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-content {
            max-width: 500px;
            margin: 0 auto;
        }

        .loading-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .loading-description {
            font-size: 0.95em;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .loading-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .pattern-info {
            color: #667eea;
            font-weight: 500;
        }

        .strategy-info {
            color: #28a745;
            font-weight: 500;
        }

        .progress-container {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e6ff;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            width: 0%;
            animation: progressPulse 2s ease-in-out infinite;
            transition: width 0.3s ease;
        }

        @keyframes progressPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.8em;
            color: #666;
        }

        .progress-step {
            display: flex;
            align-items: center;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .progress-step.active {
            opacity: 1;
            color: #667eea;
            font-weight: 500;
        }

        .progress-step.completed {
            opacity: 1;
            color: #28a745;
        }

        .progress-step-icon {
            margin-right: 4px;
        }

        .time-estimate {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            margin-top: 15px;
            display: inline-block;
        }

        .loading-status {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 6px;
            font-size: 0.9em;
            color: #555;
            border-left: 3px solid #667eea;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loading-tips {
            margin-top: 15px;
            font-size: 0.85em;
            color: #888;
            font-style: italic;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
        }

        .error {
            background: #fee;
            border: 2px solid #fcc;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .error.active {
            display: block;
        }

        .success {
            background: #efe;
            border: 2px solid #cfc;
            color: #3c3;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .success.active {
            display: block;
        }

        .quick-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .example-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .example-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .example-title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        .example-desc {
            font-size: 0.9em;
            color: #666;
        }

        .recent-patterns {
            margin-bottom: 20px;
        }

        .recent-patterns-title {
            font-size: 1em;
            color: #666;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .recent-patterns-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 32px;
            padding: 12px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }

        .recent-pattern-btn {
            padding: 6px 12px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
        }

        .recent-pattern-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .recent-pattern-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 1000;
            max-width: 250px;
            word-wrap: break-word;
            margin-bottom: 5px;
        }

        .no-recent-patterns {
            color: #999;
            font-style: italic;
            font-size: 0.9em;
        }

        /* Auto-save indicator styles */
        .auto-save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 100;
            pointer-events: none;
        }

        .auto-save-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .draft-restore-notification {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            animation: slideInDown 0.3s ease;
        }

        .draft-restore-notification.show {
            display: flex;
        }

        .draft-restore-notification .message {
            flex: 1;
        }

        .draft-restore-notification .actions {
            display: flex;
            gap: 10px;
            margin-left: 20px;
        }

        .draft-restore-notification button {
            padding: 6px 12px;
            font-size: 0.85em;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .draft-restore-notification button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® Fabric AI Web Interface</h1>
            <p>Interact with your Fabric patterns through a beautiful web interface</p>
        </div>

        <div class="main-content">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="patternCount">Loading...</div>
                    <div class="stat-label">Available Patterns</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">GLM-4.6</div>
                    <div class="stat-label">AI Model</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">9</div>
                    <div class="stat-label">Strategies</div>
                </div>
            </div>

            <!-- Draft Restore Notification -->
            <div class="draft-restore-notification" id="draftRestoreNotification">
                <div class="message">
                    <strong>üìù Draft restored!</strong> We found your previous work and restored it for you.
                </div>
                <div class="actions">
                    <button onclick="clearDrafts()">Clear Draft</button>
                    <button onclick="hideDraftNotification()">Dismiss</button>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Pattern Selection</h2>

                <!-- Recent Patterns Section -->
                <div class="recent-patterns">
                    <div class="recent-patterns-title">üïê Recent Patterns:</div>
                    <div class="recent-patterns-list" id="recentPatternsList">
                        <div class="no-recent-patterns">No recent patterns yet. Process some text to see your history here.</div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="pattern">Choose a Pattern:</label>
                    <select id="pattern" onchange="updateRecommendedStrategy()">
                        <option value="">Loading patterns...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="strategy">
                        Reasoning Strategy:
                        <span id="strategyIndicator" style="font-size: 0.85em; color: #667eea; font-weight: normal;"></span>
                    </label>
                    <select id="strategy">
                        <option value="">Auto (Default) - Automatically selects best strategy for the pattern</option>
                        <option value="standard">‚ö° Standard - Direct, immediate answers without explanation (fastest, most efficient)</option>
                        <option value="cot">üß† Chain-of-Thought - Shows complete step-by-step reasoning process for transparency</option>
                        <option value="cod">‚úèÔ∏è Chain-of-Draft - Compact reasoning with brief steps for efficiency with clarity</option>
                        <option value="ltm">üìö Least-to-Most - Breaks problems into simple building blocks, solving progressively (ideal for learning)</option>
                        <option value="tot">üå≥ Tree-of-Thought - Explores multiple creative approaches in parallel before choosing best path</option>
                        <option value="aot">‚öõÔ∏è Atom-of-Thought - Decomposes tasks into independent atomic components for systematic analysis</option>
                        <option value="reflexion">üîç Reflexion - Self-critique and refinement cycle ensuring high-quality critical analysis</option>
                        <option value="self-refine">‚ú® Self-Refine - Multiple iterative improvement cycles to polish output to perfection</option>
                        <option value="self-consistent">‚úÖ Self-Consistent - Generates multiple solutions and verifies agreement for accuracy (slowest, most reliable)</option>
                    </select>
                    <div style="margin-top: 8px; font-size: 0.85em; color: #666;" id="strategyDescription">
                        Strategy will be automatically selected based on pattern type
                    </div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Quick Examples</h2>
                <div class="quick-examples">
                    <div class="example-card" onclick="loadExample('summarize', 'Artificial Intelligence is transforming industries worldwide. Machine learning algorithms can now process vast amounts of data and identify patterns that humans might miss. Companies are using AI for everything from customer service chatbots to medical diagnosis.')">
                        <div class="example-title">üìù Summarize</div>
                        <div class="example-desc">Create a summary of text</div>
                    </div>
                    <div class="example-card" onclick="loadExample('extract_wisdom', 'The key to success is not just working hard, but working smart. Focus on what truly matters, eliminate distractions, and continuously learn from your experiences. Embrace failure as a teacher, and remember that persistence often matters more than talent.')">
                        <div class="example-title">üí° Extract Wisdom</div>
                        <div class="example-desc">Pull key insights from content</div>
                    </div>
                    <div class="example-card" onclick="loadExample('improve_writing', 'The product is good and works nice. It has many features and is not expensive. I think people will like it alot.')">
                        <div class="example-title">‚úçÔ∏è Improve Writing</div>
                        <div class="example-desc">Enhance text quality</div>
                    </div>
                    <div class="example-card" onclick="loadExample('analyze_claims', 'Studies show that drinking 8 glasses of water per day is essential for health. This has been proven by science and is universally accepted by all doctors.')">
                        <div class="example-title">üîç Analyze Claims</div>
                        <div class="example-desc">Fact-check statements</div>
                    </div>
                    <div class="example-card" onclick="loadYouTubeExample('extract_wisdom', 'https://www.youtube.com/watch?v=dQw4w9WgXcQ')">
                        <div class="example-title">üé• YouTube Wisdom</div>
                        <div class="example-desc">Extract insights from video</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Input</h2>

                <!-- Toggle between text, YouTube, and Upload -->
                <div class="form-group">
                    <label>Input Type:</label>
                    <div class="button-group">
                        <button class="btn-secondary" id="btnText" onclick="switchInputType('text')" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            üìù Text
                        </button>
                        <button class="btn-secondary" id="btnYoutube" onclick="switchInputType('youtube')">
                            üé• YouTube URL
                        </button>
                        <button class="btn-secondary" id="btnUpload" onclick="switchInputType('upload')">
                            üìÑ Upload Document
                        </button>
                    </div>
                </div>

                <!-- Text input (default) -->
                <div class="form-group" id="textInputGroup">
                    <label for="input">Enter your text:</label>
                    <textarea id="input" placeholder="Paste or type your text here..."></textarea>
                </div>

                <!-- YouTube input (hidden by default) -->
                <div class="form-group" id="youtubeInputGroup" style="display: none;">
                    <label for="youtubeUrl">YouTube URL:</label>
                    <input type="text" id="youtubeUrl" placeholder="https://youtube.com/watch?v=..." />
                    <div style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="includeTimestamps" style="width: auto; margin-right: 8px;">
                            Include timestamps in transcript
                        </label>
                    </div>
                </div>

                <!-- Upload input (hidden by default) -->
                <div class="form-group" id="uploadInputGroup" style="display: none;">
                    <label for="fileUpload">Upload Document:</label>
                    <input type="file" id="fileUpload" accept=".txt,.md,.pdf,.doc,.docx,.html,.json,.csv" style="padding: 10px; border: 2px dashed #667eea; border-radius: 8px; background: #f8f9fa; cursor: pointer;" onchange="handleFileUpload(event)" />
                    <div id="uploadStatus" style="margin-top: 10px; color: #667eea; font-size: 0.9em;"></div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        <strong>Supported formats:</strong> TXT, MD, PDF, DOC, DOCX, HTML, JSON, CSV
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="button-group">
                    <button class="btn-primary" onclick="processText()">üöÄ Process with Fabric</button>
                    <button class="btn-secondary" onclick="clearAll()">üîÑ Clear All</button>
                </div>
            </div>

            <!-- Chain Pattern Dialog -->
            <div id="chainDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 1000; max-width: 500px; width: 90%;">
                <h3 style="margin-bottom: 20px; color: #667eea;">üîó Chain Another Pattern</h3>
                <p style="margin-bottom: 20px; color: #666;">Process the output with another pattern:</p>
                <div class="form-group">
                    <label for="chainPattern">Select Pattern:</label>
                    <select id="chainPattern">
                        <option value="">Select a pattern...</option>
                    </select>
                </div>
                <div class="button-group" style="margin-top: 20px;">
                    <button class="btn-primary" onclick="executeChain()">‚ñ∂Ô∏è Run Chain</button>
                    <button class="btn-secondary" onclick="closeChainDialog()">‚úñÔ∏è Cancel</button>
                </div>
            </div>
            <div id="chainOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeChainDialog()"></div>

            <!-- Save to Obsidian Dialog -->
            <div id="saveDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 1000; max-width: 500px; width: 90%;">
                <h3 style="margin-bottom: 20px; color: #667eea;">üíæ Save to Obsidian</h3>
                <p style="margin-bottom: 20px; color: #666;">Save this output to your Obsidian vault with metadata:</p>
                <div class="form-group">
                    <label for="saveTitle">Title (required):</label>
                    <input type="text" id="saveTitle" placeholder="Enter note title..." style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em;">
                </div>
                <div class="form-group">
                    <label for="saveTags">Custom Tags (optional, comma-separated):</label>
                    <input type="text" id="saveTags" placeholder="e.g., research, important, project-name" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em;">
                </div>
                <div class="button-group" style="margin-top: 20px;">
                    <button class="btn-primary" onclick="saveToObsidian()">üíæ Save</button>
                    <button class="btn-secondary" onclick="closeSaveDialog()">‚úñÔ∏è Cancel</button>
                </div>
            </div>
            <div id="saveOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeSaveDialog()"></div>

            <div class="loading" id="loading">
                <div class="loading-header">
                    <div class="spinner"></div>
                </div>
                <div class="loading-content">
                    <div class="loading-title" id="loadingTitle">Processing with AI</div>
                    <div class="loading-description" id="loadingDescription">Please wait while we process your request...</div>
                    <div class="loading-meta">
                        <div class="pattern-info" id="loadingPattern">Pattern: Loading...</div>
                        <div class="strategy-info" id="loadingStrategy">Strategy: Auto</div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-steps" id="progressSteps">
                            <div class="step active" id="step1">
                                <div class="step-icon">üì•</div>
                                <div class="step-label">Fetching</div>
                            </div>
                            <div class="step" id="step2">
                                <div class="step-icon">‚ö°</div>
                                <div class="step-label">Processing</div>
                            </div>
                            <div class="step" id="step3">
                                <div class="step-icon">‚ú®</div>
                                <div class="step-label">Refining</div>
                            </div>
                        </div>
                    </div>
                    <div class="time-estimate" id="timeEstimate">Estimated time: 30-60 seconds</div>
                    <div class="loading-status" id="loadingStatus">Initializing...</div>
                    <div class="loading-tips" id="loadingTips">
                        <div class="tip-icon">üí°</div>
                        <div class="tip-text" id="tipText">Processing time varies based on content length and complexity.</div>
                    </div>
                </div>
            </div>

            <div class="error" id="error"></div>
            <div class="success" id="success"></div>

            <div class="output-section">
                <h2 class="section-title">Output</h2>
                <div class="button-group" id="outputButtonGroup" style="display: none; margin-bottom: 15px;">
                    <button class="btn-secondary" id="chainBtn" onclick="showChainDialog()">üîó Chain Pattern</button>
                    <button class="btn-secondary" id="copyBtn" onclick="copyOutputFromResults()">üìã Copy</button>
                    <button class="btn-secondary" id="saveBtn" onclick="showSaveDialog()">üíæ Save to Obsidian</button>
                </div>
                <div class="output" id="output">Your results will appear here...</div>
            </div>
        </div>
    </div>

    <!-- Auto-save indicator -->
    <div class="auto-save-indicator" id="autoSaveIndicator">
        ‚úÖ Draft saved
    </div>

    <script>
        const API_BASE = 'http://localhost:3000';

        // Auto-save Drafts functionality
        const DRAFT_TEXT_KEY = 'tailor-draft-text';
        const DRAFT_YOUTUBE_KEY = 'tailor-draft-youtube';
        const DRAFT_PATTERN_KEY = 'tailor-draft-pattern';
        const DRAFT_STRATEGY_KEY = 'tailor-draft-strategy';
        const DRAFT_INPUT_TYPE_KEY = 'tailor-draft-input-type';
        const AUTO_SAVE_DELAY = 300; // 300ms debounce delay

        let autoSaveTimeout = null;
        let hasRestoredDraft = false;

        // Save draft to localStorage
        function saveDraft() {
            try {
                const currentInputType = window.currentInputType || 'text';
                const pattern = document.getElementById('pattern').value;
                const strategy = document.getElementById('strategy').value;

                let draftData = {
                    inputType: currentInputType,
                    pattern: pattern,
                    strategy: strategy,
                    timestamp: new Date().toISOString()
                };

                if (currentInputType === 'text') {
                    const textInput = document.getElementById('input').value;
                    if (textInput.trim()) {
                        localStorage.setItem(DRAFT_TEXT_KEY, textInput);
                        draftData.hasText = true;
                    } else {
                        localStorage.removeItem(DRAFT_TEXT_KEY);
                        draftData.hasText = false;
                    }
                } else if (currentInputType === 'youtube') {
                    const youtubeUrl = document.getElementById('youtubeUrl').value;
                    if (youtubeUrl.trim()) {
                        localStorage.setItem(DRAFT_YOUTUBE_KEY, youtubeUrl);
                        draftData.hasYoutube = true;
                    } else {
                        localStorage.removeItem(DRAFT_YOUTUBE_KEY);
                        draftData.hasYoutube = false;
                    }
                }

                // Save pattern and strategy
                if (pattern) {
                    localStorage.setItem(DRAFT_PATTERN_KEY, pattern);
                } else {
                    localStorage.removeItem(DRAFT_PATTERN_KEY);
                }

                if (strategy) {
                    localStorage.setItem(DRAFT_STRATEGY_KEY, strategy);
                } else {
                    localStorage.removeItem(DRAFT_STRATEGY_KEY);
                }

                localStorage.setItem(DRAFT_INPUT_TYPE_KEY, currentInputType);

                // Show auto-save indicator
                showAutoSaveIndicator();

            } catch (error) {
                console.warn('Failed to save draft:', error);
                // Handle localStorage quota exceeded
                if (error.name === 'QuotaExceededError') {
                    clearOldDrafts();
                }
            }
        }

        // Debounced save function
        function debouncedSave() {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(saveDraft, AUTO_SAVE_DELAY);
        }

        // Show auto-save indicator
        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.classList.add('show');

            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // Restore draft from localStorage
        function restoreDraft() {
            try {
                const textDraft = localStorage.getItem(DRAFT_TEXT_KEY);
                const youtubeDraft = localStorage.getItem(DRAFT_YOUTUBE_KEY);
                const patternDraft = localStorage.getItem(DRAFT_PATTERN_KEY);
                const strategyDraft = localStorage.getItem(DRAFT_STRATEGY_KEY);
                const inputTypeDraft = localStorage.getItem(DRAFT_INPUT_TYPE_KEY);

                let hasDraft = false;
                let restoredFields = [];

                // Restore input type first
                if (inputTypeDraft) {
                    switchInputType(inputTypeDraft);
                }

                // Restore text content
                if (textDraft && textDraft.trim()) {
                    document.getElementById('input').value = textDraft;
                    hasDraft = true;
                    restoredFields.push('text');
                }

                // Restore YouTube URL
                if (youtubeDraft && youtubeDraft.trim()) {
                    document.getElementById('youtubeUrl').value = youtubeDraft;
                    hasDraft = true;
                    restoredFields.push('YouTube URL');
                }

                // Restore pattern
                if (patternDraft) {
                    document.getElementById('pattern').value = patternDraft;
                    updateRecommendedStrategy();
                    hasDraft = true;
                    restoredFields.push('pattern');
                }

                // Restore strategy
                if (strategyDraft) {
                    document.getElementById('strategy').value = strategyDraft;
                    hasDraft = true;
                    restoredFields.push('strategy');
                }

                // Show notification if we restored something
                if (hasDraft && !hasRestoredDraft) {
                    hasRestoredDraft = true;
                    showDraftNotification(restoredFields);
                }

                return hasDraft;
            } catch (error) {
                console.warn('Failed to restore draft:', error);
                return false;
            }
        }

        // Show draft restore notification
        function showDraftNotification(restoredFields) {
            const notification = document.getElementById('draftRestoreNotification');
            const messageElement = notification.querySelector('.message');

            const fieldsText = restoredFields.join(', ');
            messageElement.innerHTML = `<strong>üìù Draft restored!</strong> We found your previous ${fieldsText} and restored it for you.`;

            notification.classList.add('show');
        }

        // Hide draft notification
        function hideDraftNotification() {
            const notification = document.getElementById('draftRestoreNotification');
            notification.classList.remove('show');
        }

        // Clear all drafts
        function clearDrafts() {
            try {
                localStorage.removeItem(DRAFT_TEXT_KEY);
                localStorage.removeItem(DRAFT_YOUTUBE_KEY);
                localStorage.removeItem(DRAFT_PATTERN_KEY);
                localStorage.removeItem(DRAFT_STRATEGY_KEY);
                localStorage.removeItem(DRAFT_INPUT_TYPE_KEY);

                hideDraftNotification();
                showSuccess('Drafts cleared successfully!');
            } catch (error) {
                console.warn('Failed to clear drafts:', error);
                showError('Failed to clear drafts');
            }
        }

        // Clear specific field draft when field is manually cleared
        function clearFieldDraft(fieldType) {
            try {
                if (fieldType === 'text') {
                    localStorage.removeItem(DRAFT_TEXT_KEY);
                } else if (fieldType === 'youtube') {
                    localStorage.removeItem(DRAFT_YOUTUBE_KEY);
                } else if (fieldType === 'pattern') {
                    localStorage.removeItem(DRAFT_PATTERN_KEY);
                } else if (fieldType === 'strategy') {
                    localStorage.removeItem(DRAFT_STRATEGY_KEY);
                }
            } catch (error) {
                console.warn('Failed to clear field draft:', error);
            }
        }

        // Clear old drafts to handle quota issues
        function clearOldDrafts() {
            try {
                // Remove old/invalid draft data
                const keys = [
                    DRAFT_TEXT_KEY,
                    DRAFT_YOUTUBE_KEY,
                    DRAFT_PATTERN_KEY,
                    DRAFT_STRATEGY_KEY,
                    DRAFT_INPUT_TYPE_KEY
                ];

                keys.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value && (value.length > 100000 || value.trim() === '')) {
                        localStorage.removeItem(key);
                    }
                });
            } catch (error) {
                console.warn('Failed to clear old drafts:', error);
            }
        }

        // Set up auto-save event listeners
        function setupAutoSave() {
            // Text input auto-save
            const textInput = document.getElementById('input');
            if (textInput) {
                textInput.addEventListener('input', debouncedSave);
                textInput.addEventListener('blur', saveDraft);
            }

            // YouTube URL auto-save
            const youtubeInput = document.getElementById('youtubeUrl');
            if (youtubeInput) {
                youtubeInput.addEventListener('input', debouncedSave);
                youtubeInput.addEventListener('blur', saveDraft);
            }

            // Pattern selection auto-save
            const patternSelect = document.getElementById('pattern');
            if (patternSelect) {
                patternSelect.addEventListener('change', () => {
                    debouncedSave();
                    updateRecommendedStrategy();
                });
            }

            // Strategy selection auto-save
            const strategySelect = document.getElementById('strategy');
            if (strategySelect) {
                strategySelect.addEventListener('change', debouncedSave);
            }

            // Clear drafts when "Clear All" is clicked
            const originalClearAll = clearAll;
            clearAll = function() {
                clearDrafts();
                originalClearAll();
            };
        }

        // Strategy mapping based on pattern names
        const strategyMap = {
            // Analysis patterns benefit from step-by-step or self-critique
            'analyze': 'cot',
            'review': 'reflexion',
            'check': 'self-consistent',
            'compare': 'self-consistent',
            'rate': 'reflexion',

            // Creation patterns benefit from exploring multiple approaches
            'create': 'tot',
            'write': 'tot',
            'generate': 'tot',
            'design': 'aot',
            'build': 'aot',

            // Extraction patterns can use concise approaches
            'extract': 'cod',
            'get': 'standard',
            'find': 'standard',
            'pull': 'cod',

            // Summary patterns benefit from concise reasoning
            'summarize': 'cod',
            'summary': 'cod',
            'tldr': 'standard',

            // Improvement patterns benefit from iterative refinement
            'improve': 'self-refine',
            'enhance': 'self-refine',
            'refine': 'self-refine',
            'optimize': 'reflexion',
            'fix': 'reflexion',

            // Learning/teaching patterns benefit from progressive approach
            'explain': 'ltm',
            'teach': 'ltm',
            'learn': 'ltm',
            'understand': 'cot',

            // Label patterns (for categorization/tagging)
            'label': 'standard'
        };

        // Strategy descriptions for user guidance
        const strategyDescriptions = {
            '': 'Strategy will be automatically selected based on pattern type',
            'standard': 'Fast, direct answers without explanation - best for quick facts',
            'cot': 'Shows step-by-step reasoning - great for understanding the thought process',
            'cod': 'Compact reasoning with brief steps - efficient yet transparent',
            'ltm': 'Breaks down problems from simple to complex - ideal for learning',
            'tot': 'Explores multiple creative approaches - perfect for design and strategy',
            'aot': 'Decomposes into independent atomic parts - excellent for system design',
            'reflexion': 'Self-critique and refinement - ensures high-quality critical analysis',
            'self-refine': 'Iterative improvement cycles - polishes output to perfection',
            'self-consistent': 'Multiple verification paths for accuracy - slowest but most reliable'
        };

        // Get recommended strategy for a pattern
        function getRecommendedStrategy(patternName) {
            if (!patternName) return null;

            const lowerPattern = patternName.toLowerCase();

            // Check each strategy mapping key
            for (const [keyword, strategy] of Object.entries(strategyMap)) {
                if (lowerPattern.includes(keyword)) {
                    return strategy;
                }
            }

            // Default to auto (no strategy specified)
            return null;
        }

        // Update recommended strategy when pattern changes
        function updateRecommendedStrategy() {
            const patternSelect = document.getElementById('pattern');
            const strategySelect = document.getElementById('strategy');
            const indicator = document.getElementById('strategyIndicator');
            const description = document.getElementById('strategyDescription');

            const selectedPattern = patternSelect.value;

            if (!selectedPattern) {
                indicator.textContent = '';
                description.textContent = 'Strategy will be automatically selected based on pattern type';
                return;
            }

            const recommended = getRecommendedStrategy(selectedPattern);

            // Always default to Auto for now (strategies can cause timeouts)
            strategySelect.value = '';

            if (recommended) {
                // Show recommendation but don't auto-select
                indicator.innerHTML = `üí° <em>Recommended: ${getStrategyName(recommended)} (optional)</em>`;
                description.textContent = `Auto mode is fastest. You can optionally select ${getStrategyName(recommended)} for this pattern type.`;
            } else {
                // No specific recommendation, use auto
                indicator.textContent = '';
                description.textContent = 'Auto mode selected - fastest processing';
            }
        }

        // Get human-readable strategy name
        function getStrategyName(strategyValue) {
            const option = document.querySelector(`#strategy option[value="${strategyValue}"]`);
            return option ? option.textContent.split(' - ')[0].replace(/^[‚ö°üß†‚úèÔ∏èüìöüå≥‚öõÔ∏èüîç‚ú®‚úÖ]\s*/, '') : strategyValue;
        }

        // Update description when user manually changes strategy
        document.addEventListener('DOMContentLoaded', function() {
            const strategySelect = document.getElementById('strategy');
            const indicator = document.getElementById('strategyIndicator');
            const description = document.getElementById('strategyDescription');

            strategySelect.addEventListener('change', function() {
                const selected = this.value;
                description.textContent = strategyDescriptions[selected] || 'Custom strategy selected';

                // Update indicator if user overrides recommendation
                const pattern = document.getElementById('pattern').value;
                const recommended = getRecommendedStrategy(pattern);

                if (selected === recommended && recommended) {
                    indicator.innerHTML = `üí° <em>Recommended: ${getStrategyName(selected)}</em>`;
                } else if (selected && selected !== recommended) {
                    indicator.innerHTML = `üîß <em>Manual override</em>`;
                } else {
                    indicator.textContent = '';
                }
            });
        });

        // Load patterns on page load
        async function loadPatterns() {
            try {
                const response = await fetch(`${API_BASE}/patterns/details`);
                const patterns = await response.json();

                const select = document.getElementById('pattern');
                select.innerHTML = '<option value="">Select a pattern...</option>';

                const chainSelect = document.getElementById('chainPattern');
                chainSelect.innerHTML = '<option value="">Select a pattern...</option>';

                patterns.forEach(pattern => {
                    const option = document.createElement('option');
                    option.value = pattern.name;

                    // Format: "pattern_name - Description here"
                    if (pattern.description) {
                        option.textContent = `${pattern.name} - ${pattern.description}`;
                    } else {
                        option.textContent = pattern.name;
                    }

                    select.appendChild(option);

                    // Chain selector gets same formatting
                    const chainOption = document.createElement('option');
                    chainOption.value = pattern.name;
                    if (pattern.description) {
                        chainOption.textContent = `${pattern.name} - ${pattern.description}`;
                    } else {
                        chainOption.textContent = pattern.name;
                    }
                    chainSelect.appendChild(chainOption);
                });

                document.getElementById('patternCount').textContent = patterns.length;
            } catch (error) {
                showError('Failed to load patterns. Make sure the Fabric server is running on port 3000.');
                document.getElementById('patternCount').textContent = 'Error';
            }
        }

        // Load example
        function loadExample(pattern, text) {
            switchInputType('text');
            document.getElementById('pattern').value = pattern;
            document.getElementById('input').value = text;
            hideMessages();
        }

        // Load YouTube example
        function loadYouTubeExample(pattern, url) {
            switchInputType('youtube');
            document.getElementById('pattern').value = pattern;
            document.getElementById('youtubeUrl').value = url;
            hideMessages();
        }

        // Track current input type and uploaded file content
        let currentInputType = 'text';
        let uploadedFileContent = '';

        // Switch between text, YouTube, and upload input
        function switchInputType(type) {
            currentInputType = type;
            window.currentInputType = type; // Update global variable for auto-save

            const textGroup = document.getElementById('textInputGroup');
            const youtubeGroup = document.getElementById('youtubeInputGroup');
            const uploadGroup = document.getElementById('uploadInputGroup');
            const btnText = document.getElementById('btnText');
            const btnYoutube = document.getElementById('btnYoutube');
            const btnUpload = document.getElementById('btnUpload');

            // Hide all groups
            textGroup.style.display = 'none';
            youtubeGroup.style.display = 'none';
            uploadGroup.style.display = 'none';

            // Reset all buttons
            btnText.style.background = '#f0f0f0';
            btnText.style.color = '#333';
            btnYoutube.style.background = '#f0f0f0';
            btnYoutube.style.color = '#333';
            btnUpload.style.background = '#f0f0f0';
            btnUpload.style.color = '#333';

            // Show selected group and highlight button
            if (type === 'text') {
                textGroup.style.display = 'block';
                btnText.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btnText.style.color = 'white';
            } else if (type === 'youtube') {
                youtubeGroup.style.display = 'block';
                btnYoutube.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btnYoutube.style.color = 'white';
            } else if (type === 'upload') {
                uploadGroup.style.display = 'block';
                btnUpload.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btnUpload.style.color = 'white';
            }

            // Trigger auto-save when switching input types
            debouncedSave();
        }

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const uploadStatus = document.getElementById('uploadStatus');
            uploadStatus.textContent = `Reading ${file.name}...`;

            const reader = new FileReader();

            reader.onload = function(e) {
                uploadedFileContent = e.target.result;
                uploadStatus.innerHTML = `‚úÖ <strong>${file.name}</strong> loaded (${(file.size / 1024).toFixed(2)} KB)`;
                uploadStatus.style.color = '#28a745';
            };

            reader.onerror = function() {
                uploadStatus.innerHTML = `‚ùå Error reading file`;
                uploadStatus.style.color = '#dc3545';
            };

            // Read as text
            reader.readAsText(file);
        }

        // Process text with selected pattern
        async function processText() {
            const pattern = document.getElementById('pattern').value;
            const strategy = document.getElementById('strategy').value;

            if (!pattern) {
                showError('Please select a pattern first.');
                return;
            }

            let input, isYouTube = false, includeTimestamps = false;

            if (currentInputType === 'youtube') {
                input = document.getElementById('youtubeUrl').value.trim();
                includeTimestamps = document.getElementById('includeTimestamps').checked;
                isYouTube = true;

                if (!input) {
                    showError('Please enter a YouTube URL.');
                    return;
                }

                // Basic YouTube URL validation
                if (!input.includes('youtube.com') && !input.includes('youtu.be')) {
                    showError('Please enter a valid YouTube URL.');
                    return;
                }
            } else if (currentInputType === 'upload') {
                input = uploadedFileContent;

                if (!input || !input.trim()) {
                    showError('Please upload a document first.');
                    return;
                }
            } else {
                input = document.getElementById('input').value;

                if (!input.trim()) {
                    showError('Please enter some text to process.');
                    return;
                }
            }

            hideMessages();
            showLoading(true);

            // Enhanced loading initialization
            const patternDisplayName = pattern.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const strategyDisplayName = strategy === 'auto' ? 'Auto' : strategy.charAt(0).toUpperCase() + strategy.slice(1);

            // Calculate time estimate based on content
            const contentLength = input.length;
            const contentType = isYouTube ? 'youtube' : 'text';
            const timeEstimate = calculateTimeEstimate(contentLength, contentType);

            // Initialize enhanced loading state
            updateLoadingState({
                pattern: patternDisplayName,
                strategy: strategyDisplayName,
                timeEstimate: timeEstimate
            });

            document.getElementById('output').textContent = isYouTube ?
                'Fetching YouTube transcript...' : 'Processing with AI...';

            try {
                // Set initial loading state
                if (isYouTube) {
                    setLoadingState('youtube-fetching');
                    startAnimatedProgress(3, 45000); // 45 seconds for YouTube processing
                } else {
                    setLoadingState('analyzing', {
                        pattern: patternDisplayName,
                        strategy: strategyDisplayName
                    });
                    startAnimatedProgress(3, 35000); // 35 seconds for text processing
                }

                // Add delay to show initial loading state
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Update to pattern application state
                if (isYouTube) {
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate YouTube fetch time
                    updateLoadingState({
                        status: 'Transcript fetched successfully',
                        progress: 40
                    });

                    await new Promise(resolve => setTimeout(resolve, 1000));

                    setLoadingState('applying-pattern', {
                        pattern: patternDisplayName,
                        strategy: strategyDisplayName
                    });
                } else {
                    setLoadingState('applying-pattern', {
                        pattern: patternDisplayName,
                        strategy: strategyDisplayName
                    });
                }

                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: input,
                        pattern: pattern,
                        strategy: strategy || undefined,
                        isYouTube: isYouTube,
                        includeTimestamps: includeTimestamps
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    setLoadingState('error');
                    throw new Error(`Server error (${response.status}): ${errorText}`);
                }

                // Update to finalizing state
                setLoadingState('finalizing');
                updateProgressBar(90);

                const result = await response.text();

                // Check if result is empty or just whitespace
                if (!result || !result.trim()) {
                    setLoadingState('error');
                    throw new Error('Received empty response from server. Check if API keys are configured correctly.');
                }

                // Complete the progress bar
                updateProgressBar(100);

                // Brief pause to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                document.getElementById('output').textContent = result;
                showSuccess('Processing complete!');

                // Show the output button group after successful processing
                document.getElementById('outputButtonGroup').style.display = 'flex';
            } catch (error) {
                setLoadingState('error');
                showError(`Error: ${error.message}`);
                document.getElementById('output').textContent = 'Error occurred. See message above.';
                console.error('Full error:', error);
            } finally {
                showLoading(false);
            }
        }

        // Clear all fields
        function clearAll() {
            document.getElementById('pattern').value = '';
            document.getElementById('input').value = '';
            document.getElementById('youtubeUrl').value = '';
            document.getElementById('includeTimestamps').checked = false;
            document.getElementById('fileUpload').value = '';
            document.getElementById('uploadStatus').textContent = '';
            uploadedFileContent = '';
            document.getElementById('output').textContent = 'Your results will appear here...';
            document.getElementById('outputButtonGroup').style.display = 'none';
            hideMessages();
        }

        // Copy output to clipboard (from results section)
        async function copyOutputFromResults() {
            const output = document.getElementById('output').textContent;

            if (output === 'Your results will appear here...' || output === 'Processing...' || output === 'Error occurred. See message above.') {
                showError('No output to copy yet.');
                return;
            }

            try {
                // Use modern Clipboard API if available
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(output);
                    showSuccess('‚úÖ Output copied to clipboard!');
                } else {
                    // Fallback for older browsers
                    copyToClipboardFallback(output);
                    showSuccess('‚úÖ Output copied to clipboard!');
                }
            } catch (error) {
                console.error('Clipboard copy failed:', error);
                // Try fallback method
                try {
                    copyToClipboardFallback(output);
                    showSuccess('‚úÖ Output copied to clipboard!');
                } catch (fallbackError) {
                    console.error('Fallback clipboard copy failed:', fallbackError);
                    showError('‚ùå Failed to copy to clipboard. Please copy manually.');
                }
            }
        }

        // Fallback clipboard copy method for older browsers
        function copyToClipboardFallback(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);

            if (!successful) {
                throw new Error('Failed to copy text');
            }
        }

        // Legacy copy function (deprecated but kept for compatibility)
        async function copyOutput() {
            copyOutputFromResults();
        }

        // Enhanced Loading State Management
        let currentLoadingState = 'idle';
        let loadingProgressInterval = null;
        let loadingStartTime = null;
        let currentProgressStep = 0;

        // Main showLoading function - maintains backward compatibility
        function showLoading(show) {
            const loading = document.getElementById('loading');
            loading.className = show ? 'loading active' : 'loading';

            if (show) {
                loadingStartTime = Date.now();
                resetLoadingState();
                updateLoadingState({
                    title: 'Processing with AI',
                    description: 'Please wait while we process your request...',
                    status: 'Initializing...',
                    step: 1
                });
            } else {
                clearInterval(loadingProgressInterval);
                loadingProgressInterval = null;
                currentLoadingState = 'idle';
                currentProgressStep = 0;
            }
        }

        // Enhanced loading state control function
        function updateLoadingState(config) {
            if (document.getElementById('loading').className !== 'loading active') {
                return; // Don't update if loading is not active
            }

            // Update title
            if (config.title) {
                document.getElementById('loadingTitle').textContent = config.title;
            }

            // Update description
            if (config.description) {
                document.getElementById('loadingDescription').textContent = config.description;
            }

            // Update pattern and strategy
            if (config.pattern) {
                document.getElementById('loadingPattern').textContent = `Pattern: ${config.pattern}`;
            }

            if (config.strategy) {
                document.getElementById('loadingStrategy').textContent = `Strategy: ${config.strategy}`;
            }

            // Update status
            if (config.status) {
                document.getElementById('loadingStatus').textContent = config.status;
            }

            // Update progress steps
            if (config.step !== undefined) {
                updateProgressStep(config.step);
            }

            // Update progress bar
            if (config.progress !== undefined) {
                updateProgressBar(config.progress);
            }

            // Update time estimate
            if (config.timeEstimate) {
                document.getElementById('timeEstimate').textContent = config.timeEstimate;
            }

            // Update tips
            if (config.tip) {
                document.getElementById('tipText').textContent = config.tip;
            }
        }

        // Update progress step indicators
        function updateProgressStep(stepNumber) {
            const steps = document.querySelectorAll('.step');
            steps.forEach((step, index) => {
                if (index < stepNumber - 1) {
                    step.classList.add('completed');
                    step.classList.remove('active');
                } else if (index === stepNumber - 1) {
                    step.classList.add('active');
                    step.classList.remove('completed');
                } else {
                    step.classList.remove('active', 'completed');
                }
            });
            currentProgressStep = stepNumber;
        }

        // Update progress bar fill
        function updateProgressBar(percentage) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
        }

        // Reset loading state to defaults
        function resetLoadingState() {
            document.getElementById('loadingTitle').textContent = 'Processing with AI';
            document.getElementById('loadingDescription').textContent = 'Please wait while we process your request...';
            document.getElementById('loadingPattern').textContent = 'Pattern: Loading...';
            document.getElementById('loadingStrategy').textContent = 'Strategy: Auto';
            document.getElementById('loadingStatus').textContent = 'Initializing...';
            document.getElementById('timeEstimate').textContent = 'Estimated time: 30-60 seconds';
            document.getElementById('tipText').textContent = 'Processing time varies based on content length and complexity.';
            document.getElementById('progressFill').style.width = '0%';

            // Reset steps
            const steps = document.querySelectorAll('.step');
            steps.forEach(step => {
                step.classList.remove('active', 'completed');
            });
        }

        // Start animated progress for long-running operations
        function startAnimatedProgress(totalSteps = 3, durationMs = 30000) {
            let progress = 0;
            const stepDuration = durationMs / totalSteps;

            clearInterval(loadingProgressInterval);

            loadingProgressInterval = setInterval(() => {
                progress += (100 / (durationMs / 100)); // Increment every 100ms
                updateProgressBar(Math.min(progress, 95)); // Cap at 95% until completion

                // Auto-advance steps based on progress
                if (progress > 66 && currentProgressStep < 3) {
                    updateProgressStep(3);
                } else if (progress > 33 && currentProgressStep < 2) {
                    updateProgressStep(2);
                }

                if (progress >= 95) {
                    clearInterval(loadingProgressInterval);
                    loadingProgressInterval = null;
                }
            }, 100);
        }

        // Set loading state for specific processing stages
        function setLoadingState(state, additionalConfig = {}) {
            const states = {
                'youtube-fetching': {
                    title: 'Fetching YouTube Content',
                    description: 'Retrieving and processing video information...',
                    status: 'Connecting to YouTube...',
                    step: 1,
                    tip: 'This usually takes 10-20 seconds depending on video length.',
                    timeEstimate: 'Estimated time: 20-40 seconds'
                },
                'analyzing': {
                    title: 'Analyzing Content',
                    description: 'Processing and understanding your content with AI...',
                    status: 'Running AI analysis...',
                    step: 2,
                    tip: 'AI is carefully analyzing your content to provide the best results.',
                    timeEstimate: 'Estimated time: 30-60 seconds'
                },
                'applying-pattern': {
                    title: 'Applying Pattern',
                    description: `Applying ${additionalConfig.pattern || 'selected'} pattern to transform content...`,
                    status: 'Transforming content...',
                    step: 2,
                    tip: 'The AI is restructuring your content according to the selected pattern.',
                    timeEstimate: 'Estimated time: 15-30 seconds'
                },
                'finalizing': {
                    title: 'Finalizing Results',
                    description: 'Polishing and optimizing your output...',
                    status: 'Final touches...',
                    step: 3,
                    tip: 'Almost done! Making sure everything looks perfect.',
                    timeEstimate: 'Estimated time: 5-10 seconds'
                },
                'error': {
                    title: 'Processing Error',
                    description: 'Something went wrong while processing your request.',
                    status: 'Error occurred',
                    tip: 'Please try again or check your input content.',
                    timeEstimate: ''
                }
            };

            const config = states[state] || states['analyzing'];
            updateLoadingState({ ...config, ...additionalConfig });
        }

        // Calculate time estimate based on content length and type
        function calculateTimeEstimate(contentLength, contentType = 'text') {
            let baseTime = 15000; // 15 seconds base

            if (contentType === 'youtube') {
                baseTime = 25000; // 25 seconds base for YouTube (includes fetch time)
            }

            // Add time based on content length (rough estimate)
            const lengthMultiplier = Math.min(3, Math.max(1, contentLength / 2000));
            const estimatedMs = baseTime * lengthMultiplier;

            const seconds = Math.ceil(estimatedMs / 1000);
            const rangeStart = Math.ceil(seconds * 0.8);
            const rangeEnd = Math.ceil(seconds * 1.5);

            return `Estimated time: ${rangeStart}-${rangeEnd} seconds`;
        }

        function showError(message) {
            const error = document.getElementById('error');
            error.textContent = message;
            error.className = 'error active';
            setTimeout(() => error.className = 'error', 5000);
        }

        function showSuccess(message) {
            const success = document.getElementById('success');
            success.textContent = message;
            success.className = 'success active';
            setTimeout(() => success.className = 'success', 3000);
        }

        function hideMessages() {
            document.getElementById('error').className = 'error';
            document.getElementById('success').className = 'success';
        }

        // Chain Pattern Functions
        function showChainDialog() {
            const output = document.getElementById('output').textContent;

            if (output === 'Your results will appear here...' || output === 'Processing...' || !output.trim()) {
                showError('No output to chain. Process something first.');
                return;
            }

            document.getElementById('chainDialog').style.display = 'block';
            document.getElementById('chainOverlay').style.display = 'block';
        }

        function closeChainDialog() {
            document.getElementById('chainDialog').style.display = 'none';
            document.getElementById('chainOverlay').style.display = 'none';
            document.getElementById('chainPattern').value = '';
        }

        async function executeChain() {
            const chainPattern = document.getElementById('chainPattern').value;
            const currentOutput = document.getElementById('output').textContent;

            if (!chainPattern) {
                showError('Please select a pattern to chain.');
                return;
            }

            closeChainDialog();
            hideMessages();
            showLoading(true);

            // Enhanced loading for chain processing
            const patternDisplayName = chainPattern.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const contentLength = currentOutput.length;
            const timeEstimate = calculateTimeEstimate(contentLength, 'text');

            // Initialize chain loading state
            updateLoadingState({
                title: 'Chaining Pattern',
                description: `Applying ${patternDisplayName} to your previous output...`,
                pattern: patternDisplayName,
                strategy: 'Chain Processing',
                timeEstimate: timeEstimate,
                status: 'Preparing chain operation...'
            });

            document.getElementById('output').textContent = `Chaining with ${chainPattern}...`;

            try {
                // Start with analyzing state
                setLoadingState('analyzing', {
                    title: 'Analyzing Previous Output',
                    description: 'Processing your existing content for chaining...',
                    pattern: patternDisplayName,
                    strategy: 'Chain Processing'
                });
                startAnimatedProgress(3, 25000); // 25 seconds for chain processing

                // Add delay to show initial state
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Move to pattern application
                setLoadingState('applying-pattern', {
                    title: 'Applying Chain Pattern',
                    description: `Transforming content with ${patternDisplayName} pattern...`,
                    pattern: patternDisplayName,
                    strategy: 'Chain Processing'
                });

                await new Promise(resolve => setTimeout(resolve, 1500));

                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: currentOutput,
                        pattern: chainPattern,
                        isYouTube: false
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    setLoadingState('error');
                    throw new Error(`Server error (${response.status}): ${errorText}`);
                }

                // Update to finalizing state
                setLoadingState('finalizing', {
                    title: 'Finalizing Chain Output',
                    description: 'Completing pattern chain operation...'
                });
                updateProgressBar(90);

                const result = await response.text();

                if (!result || !result.trim()) {
                    setLoadingState('error');
                    throw new Error('Received empty response from server.');
                }

                // Complete the progress bar
                updateProgressBar(100);

                // Brief pause to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                document.getElementById('output').textContent = result;
                showSuccess(`Pattern chain complete! (${chainPattern})`);

                // Keep the output button group visible for further operations
                document.getElementById('outputButtonGroup').style.display = 'flex';
            } catch (error) {
                setLoadingState('error');
                showError(`Chain error: ${error.message}`);
                document.getElementById('output').textContent = currentOutput; // Restore previous output
                console.error('Full error:', error);
            } finally {
                showLoading(false);
            }
        }

        // Save to Obsidian Functions
        let currentProcessingData = {};

        function showSaveDialog() {
            document.getElementById('saveDialog').style.display = 'block';
            document.getElementById('saveOverlay').style.display = 'block';

            // Pre-fill title with pattern name if available
            const pattern = document.getElementById('pattern').value;
            if (pattern && !document.getElementById('saveTitle').value) {
                const suggestedTitle = pattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                document.getElementById('saveTitle').placeholder = `e.g., ${suggestedTitle} - ${new Date().toLocaleDateString()}`;
            }
        }

        function closeSaveDialog() {
            document.getElementById('saveDialog').style.display = 'none';
            document.getElementById('saveOverlay').style.display = 'none';
        }

        async function saveToObsidian() {
            const title = document.getElementById('saveTitle').value.trim();
            const tags = document.getElementById('saveTags').value.trim();

            if (!title) {
                showError('Please enter a title for your note');
                return;
            }

            const output = document.getElementById('output').textContent;
            if (!output || output === 'Your results will appear here...') {
                showError('No output to save');
                return;
            }

            // Get current processing context
            const pattern = document.getElementById('pattern').value;
            const strategy = document.getElementById('strategy').value;
            const inputType = currentInputType;
            const youtubeUrl = inputType === 'youtube' ? document.getElementById('youtubeUrl').value : null;
            const fileName = inputType === 'upload' ? uploadedFileName : null;

            // Parse custom tags
            const customTags = tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [];

            const saveData = {
                title: title,
                content: output,
                pattern: pattern,
                sourceType: inputType,
                sourceUrl: youtubeUrl,
                sourceFile: fileName,
                customTags: customTags,
                strategy: strategy || 'auto',
                chainedFrom: currentProcessingData.chainedFrom || null
            };

            try {
                showLoading(true);

                // Enhanced loading for save operation
                updateLoadingState({
                    title: 'Saving to Obsidian',
                    description: 'Saving your processed content to your Obsidian vault...',
                    pattern: 'Save Operation',
                    strategy: 'Local Storage',
                    timeEstimate: 'Estimated time: 2-5 seconds',
                    status: 'Preparing save data...'
                });

                // Brief delay to show loading state
                await new Promise(resolve => setTimeout(resolve, 500));

                updateLoadingState({
                    status: 'Connecting to Obsidian vault...',
                    progress: 30
                });

                const response = await fetch(`${API_BASE}/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(saveData)
                });

                if (!response.ok) {
                    setLoadingState('error');
                    throw new Error(`Save failed: ${response.statusText}`);
                }

                updateLoadingState({
                    status: 'Writing file to vault...',
                    progress: 70
                });

                const result = await response.json();

                updateLoadingState({
                    status: 'Save complete!',
                    progress: 100
                });

                // Brief pause to show completion
                await new Promise(resolve => setTimeout(resolve, 300));

                closeSaveDialog();
                showSuccess(`‚úÖ Saved to Obsidian: ${result.filename}`);

                // Clear the save form
                document.getElementById('saveTitle').value = '';
                document.getElementById('saveTags').value = '';

            } catch (error) {
                setLoadingState('error');
                showError(`Save error: ${error.message}`);
                console.error('Full error:', error);
            } finally {
                showLoading(false);
            }
        }

        // Track chained processing
        let lastPattern = null;

        // Recent Patterns History Functions
        const RECENT_PATTERNS_KEY = 'tailor-recent-patterns';
        const MAX_RECENT_PATTERNS = 10;

        // Load recent patterns from localStorage
        function loadRecentPatterns() {
            try {
                const stored = localStorage.getItem(RECENT_PATTERNS_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.warn('Failed to load recent patterns from localStorage:', error);
                return [];
            }
        }

        // Save recent patterns to localStorage
        function saveRecentPatterns(patterns) {
            try {
                localStorage.setItem(RECENT_PATTERNS_KEY, JSON.stringify(patterns));
            } catch (error) {
                console.warn('Failed to save recent patterns to localStorage:', error);
            }
        }

        // Add pattern to recent history (only after successful processing)
        function addToRecentPatterns(patternName, patternDescription) {
            if (!patternName) return;

            let recentPatterns = loadRecentPatterns();

            // Remove if already exists (to handle duplicates)
            recentPatterns = recentPatterns.filter(p => p.name !== patternName);

            // Add to beginning
            recentPatterns.unshift({
                name: patternName,
                description: patternDescription || '',
                timestamp: new Date().toISOString()
            });

            // Limit to max
            recentPatterns = recentPatterns.slice(0, MAX_RECENT_PATTERNS);

            saveRecentPatterns(recentPatterns);
            updateRecentPatternsDisplay();
        }

        // Update the display of recent patterns
        function updateRecentPatternsDisplay() {
            const container = document.getElementById('recentPatternsList');
            const recentPatterns = loadRecentPatterns();

            if (recentPatterns.length === 0) {
                container.innerHTML = '<div class="no-recent-patterns">No recent patterns yet. Process some text to see your history here.</div>';
                return;
            }

            container.innerHTML = '';

            recentPatterns.forEach(pattern => {
                const button = document.createElement('button');
                button.className = 'recent-pattern-btn';
                button.textContent = pattern.name;

                // Add tooltip with description if available
                if (pattern.description) {
                    button.setAttribute('data-tooltip', pattern.description);
                }

                // Make it clickable to select the pattern
                button.onclick = function() {
                    document.getElementById('pattern').value = pattern.name;
                    updateRecommendedStrategy();

                    // Visual feedback
                    this.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    this.style.color = 'white';
                    setTimeout(() => {
                        this.style.background = '';
                        this.style.color = '';
                    }, 300);
                };

                container.appendChild(button);
            });
        }

        // Wrap processText to add tracking and recent patterns functionality
        const originalProcessText = processText;
        processText = async function() {
            currentProcessingData.chainedFrom = null;
            const pattern = document.getElementById('pattern').value;
            lastPattern = pattern;

            try {
                await originalProcessText();

                // Only add to recent patterns if processing was successful
                const output = document.getElementById('output').textContent;
                if (output && output !== 'Your results will appear here...' &&
                    output !== 'Error occurred. See message above.' &&
                    !output.includes('...')) {

                    // Get pattern description from the select option
                    const select = document.getElementById('pattern');
                    const selectedOption = select.options[select.selectedIndex];
                    const description = selectedOption ? selectedOption.textContent.split(' - ').slice(1).join(' - ') : '';

                    addToRecentPatterns(pattern, description);
                }
            } catch (error) {
                // Let original error handling take care of it
                throw error;
            }
        };

        // Wrap executeChain to add tracking and recent patterns functionality
        const originalExecuteChain = executeChain;
        executeChain = async function() {
            currentProcessingData.chainedFrom = lastPattern;
            const pattern = document.getElementById('chainPattern').value;
            lastPattern = pattern;

            try {
                await originalExecuteChain();

                // Add to recent patterns after successful chain
                const output = document.getElementById('output').textContent;
                if (output && output !== 'Your results will appear here...' &&
                    output !== 'Error occurred. See message above.' &&
                    !output.includes('...')) {

                    // Get pattern description from the chain select option
                    const select = document.getElementById('chainPattern');
                    const selectedOption = select.options[select.selectedIndex];
                    const description = selectedOption ? selectedOption.textContent.split(' - ').slice(1).join(' - ') : '';

                    addToRecentPatterns(pattern, description);
                }
            } catch (error) {
                throw error;
            }
        };

        // Initialize on page load
        loadPatterns();
        updateRecentPatternsDisplay();

        // Initialize auto-save functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Set up auto-save event listeners
            setupAutoSave();

            // Try to restore drafts after a short delay
            setTimeout(() => {
                restoreDraft();
            }, 100);
        });
    </script>
</body>
</html>
